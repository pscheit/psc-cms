<?php

namespace Psc\Doctrine;

use Doctrine\ORM\QueryBuilder;
use Psc\CMS\EntityMeta;
use Closure;

/**
 * Synchroniziert die Collection eines Entities ($fromCollection) mit einer unhydrierten Collection ($toCollection)
 *
 * Dependencies:
 *   - UniqueEntityHydrator
 *       kann nach unique-keys und nach primary key hydrieren (benötigt $tagRepository)
 *   - das Entity in dem die Collection ist ($article)
 *   - Meta von dem Entity in dem die Collection ist ($articleMeta)
 *   - das Repository des Entities IN der Collection ($tagRepository)
 *   - EntityFactory für das Entity IN der Collection ($tagFactory)
 *      - und dessen Meta ($tagMeta)
 *     
 * Default verhalten (für article und tag):
 *   onHydrate: UniqueEntityHydrator<tag>->getEntity($toObject);
 *   onHash: return $tag->getIdentifier();
 *   onInsert: $tag = new Tag(); foreach($toObject as $field=>$value) $tag->set$field($value); $article->addTag($tag);
 *   onUpdate: foreach($toObject as $field=>$value) $tag->set$field($value); $article->addTag($tag);
 *   onDelete: $article->removeTag($tag);
 *   
 * alle Defaults können mit den on* Methoden überschrieben werden. (Siehe ActionsCollectionSynchronizerTest für Beispiele)
 * erst init() aufrufen dann on*() aufrufen (oder init ganz weglassen, um keine Defaults zu haben)
 */
class PersistentCollectionSynchronizer extends EntityCollectionSynchronizer {
  
  protected $hydrator;
  protected $factory;

  public function __construct(EntityMeta $entityMeta, $collectionName, UniqueEntityHydrator $hydrator, EntityFactory $factory, ActionsCollectionSynchronizer $actionsSynchronizer = NULL) {
    parent::__construct($entityMeta, $collectionName, $actionsSynchronizer ?: new ActionsCollectionSynchronizer());
    
    $this->hydrator = $hydrator;
    $this->factory = $factory;
  }
  
  
  /**
   * Erstellt einen Synchronizer für das $collectionPropertyName in $entityClass
   *
   * @return PersistentCollectionSynchronizer
   */
  public static function createFor($entityClass, $collectionPropertyName, DCPackage $dc) {
    $entityMeta = $dc->getEntityMeta($entityClass);
    $property = $entityMeta->getPropertyMeta($collectionPropertyName);
    $collectionClass = $property->getRelationEntityClass();
    
    $synchronizer = new static(
      $entityMeta,
      $property->getName(),
      new UniqueEntityHydrator($dc->getEntityManager()->getRepository($collectionClass->getFQN())),
      new EntityFactory($dc->getEntityMeta($collectionClass->getFQN()))
    );
    
    return $synchronizer;
  }
  
  /**
   * Initialisiert die Defaults für alle on* Methoden für das Entity mit der Collection
   *
   * ein CollectionSynchronizer kann mehrere Collections eines Types von mehreren Entities synchronisieren wenn jeweils init() für das aktuelle Entity aufgerufen wird
   *
   * new Synchronizer();
   * foreach ($articles as $article) {
   *   $synchronizer->init($article);
   *
   *   $synchronizer->process($article->getTags(), $formData[$article->getId()]);
   * }
   */
  public function init(Entity $entity) {
    parent::init($entity);
    
    $hydrator = $this->hydrator;
    $factory = $this->factory;
    $repository = $hydrator->getRepository();
    $identifier = $factory->getEntityMeta()->getIdentifier();
    $skipFields = array();
    if ($identifier->isAutogeneratedValue()) {
      $skipFields[$identifier->getName()] = TRUE;
    }
    
    list($add, $remove) = $this->getRelationInterface();
    
    // hydrate
    $this->onHydrate(function ($toObject) use ($hydrator) {
      return $hydrator->getEntity((array) $toObject); // convention: $field=>value für alle unique constraint-felder
    });

    // hash
    $this->onHash(function (Entity $entity) {
      return $entity->getIdentifier();
    });

    // insert
    $this->onInsert(function ($toObject) use ($factory, $repository, $entity, $add, $skipFields) {
      $factory->reset();
      foreach ($toObject as $field => $value) {
        if (!array_key_exists($field,$skipFields))
          $factory->set($field, $value);
      }
      
      $collectionEntity = $factory->getEntity();
      
      $entity->$add($collectionEntity);
      $repository->persist($collectionEntity);
    });


    // update (merge)
    $this->onUpdate(function (Entity $collectionEntity, $toObject) use ($repository, $entity, $add, $skipFields) {
      foreach ($toObject as $field => $value) {
        if (!array_key_exists($field,$skipFields)) {
          $collectionEntity->callSetter($field, $value);
        }
      }
      
      $entity->$add($collectionEntity);
      $repository->persist($collectionEntity);
    });
    
    
    // delete
    $this->onDelete(function (Entity $collectionEntity) use ($entity, $remove) {
      $entity->$remove($collectionEntity);
      // wenn tag 0 verknüpfungen hat, könnte man es hier auch löschen
    });
    
    return $this;
  }

  /**
   * Führt die Synchronization der Collections aus
   *
   * es muss $fromCollection = $entity->get$collectionName() sein.
   * $toCollection ist die zu hydrierende Collection
   */
  public function process($fromCollection, $toCollection) {
    $this->innerSynchronizer->process($fromCollection, $toCollection);
    return $this;
  }
  
  public function getActionsSynchronizer() {
    return $this->innerSynchronizer;
  }
}
