<?php

namespace Psc\Doctrine;

use Psc\Data\Set;
use Psc\Data\SetMeta;
use Psc\CMS\EntityMeta;

class EntityFactory {
  
  /**
   * @var Psc\Data\Set
   */
  protected $fields;

  protected $entityMeta;
  protected $entity;
  
  /**
   * Cache für die GClass aus EntityMeta
   * 
   * @var Psc\Code\Generate\GClass
   */
  protected $gClass;
  
  /**
   * Cache für die Felder die im Constructor übergeben werden können
   *
   * @var string[]
   */
  protected $constructorFields;
  
  public function __construct(EntityMeta $entityMeta) {
    $this->entityMeta = $entityMeta;
    $this->reset();
  }

  /**
   * Setzt einen Wert eines Fields für die neue Instanz die mit getEntity() zurückgegeben wird
   *
   * es sind nur Felder erlaubt die im Entity Meta Set vorhanden sind
   * @chainable
   */
  public function set($field, $value) {
    $this->fields->set($field, $value);
    return $this;
  }

  protected function createEntity() {
    $fields = $this->fields->toArray();
    
    // @TODO hier könne es sein dass unset sehr lahm ist. man könnte auch array_intersect oder sowas nehmen oder im constructor foreach was anders machen etc
    
    // zuerst die ausm constructor
    $constructParams = array();
    foreach ($this->getConstructorFields() as $field) {
      $constructParams[] = $this->fields->get($field);
      unset($fields[$field]);
    }
    
    // construct
    try {
      $entity = $this->getGClass()->newInstance($constructParams);
    } catch (\ErrorException $e) {
      throw new \Psc\Exception(
        sprintf("Fehler beim Erstellen des Entities: '%s'. Es wurden %d (%s) Parameter an den Constructor übergeben. Fehler: %s",
                $this->entityMeta->getEntityName(), count($constructParams), \Psc\Code\Code::varInfo($constructParams), $e->getMessage()
               ), 0, $e);
    }
    
    // restliche Felder (oben haben wir alle aus dem constructor unsetted)
    foreach ($fields as $field => $value) {
      if (!$this->entityMeta->getPropertyMeta($field)->isAutogeneratedValue()) {
        $entity->callSetter($field, $value);
      }
    }
    
    return $entity;
  }

  /**
   * @return Psc\CMS\Entity (der Instance wie in Metadata angegeben)
   */
  public function getEntity() {
    if (!isset($this->entity)) {
      $this->entity = $this->createEntity();
    }
    
    return $this->entity;
  }

  /**
   * Gibt die Felder zurück, die dem Entity per Constructor übergeben werden
   * @return string[]
   */
  public function getConstructorFields() {
    if (!isset($this->constructorFields)) {
      $this->constructorFields = array();
      $gClass = $this->getGClass();
      
      
      if ($gClass->hasMethod('__construct')) {
        foreach ($gClass->getMethod('__construct')->getParameters() as $parameter) {
          $this->constructorFields[] = $parameter->getName();
        }
      }
    }
    
    return $this->constructorFields;
  }
  
  public function reset() {
    $this->entity = NULL;
    $this->fields = new Set(array(), $this->entityMeta->getSetMeta());
    return $this;
  }
  
  protected function getGClass() {
    if (!isset($this->gClass)) {
      $this->gClass = $this->entityMeta->getGClass();
      $this->gClass->elevateClass();
    }
    return $this->gClass;
  }
  
  /**
   * @return Psc\CMS\EntityMeta
   */
  public function getEntityMeta() {
    return $this->entityMeta;
  }
}
